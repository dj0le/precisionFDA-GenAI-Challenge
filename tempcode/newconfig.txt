For user-configurable settings that come from the frontend, you should handle them through API endpoints and request models. Here's a recommended approach:

1. First, create Pydantic models for the user configurations:

```python
# schemas.py
from pydantic import BaseModel
from typing import Optional

class UserConfig(BaseModel):
    model: Optional[str] = None
    output_file: Optional[str] = None

class ProcessingConfig(BaseModel):
    model: str
    output_file: str

    @classmethod
    def from_user_config(cls, user_config: UserConfig, settings):
        return cls(
            model=user_config.model or settings.DEFAULT_MODEL,
            output_file=user_config.output_file or f"output_{int(time.time())}"
        )
```

2. Create API endpoints to handle configuration:

```python
# routes.py
from fastapi import APIRouter, Depends
from .schemas import UserConfig, ProcessingConfig
from .config import settings

router = APIRouter()

@router.post("/config")
async def set_configuration(config: UserConfig) -> ProcessingConfig:
    # Convert user config to processing config with defaults
    processing_config = ProcessingConfig.from_user_config(config, settings)
    return processing_config

@router.get("/config/models")
async def get_available_models():
    # Return list of available models
    return {
        "models": [
            {"id": "llama3.2", "name": "LLaMA 3.2"},
            {"id": "gpt4", "name": "GPT-4"},
            # ... other models
        ]
    }
```

3. Create a configuration manager to handle the processing configuration:

```python
# config_manager.py
from dataclasses import dataclass
from .schemas import ProcessingConfig
from .config import settings

@dataclass
class ConfigManager:
    _config: ProcessingConfig | None = None

    def set_config(self, config: ProcessingConfig) -> None:
        self._config = config

    @property
    def model(self) -> str:
        return self._config.model if self._config else settings.DEFAULT_MODEL

    @property
    def output_file(self) -> str:
        return self._config.output_file if self._config else f"output_{int(time.time())}"

# Create a singleton instance
config_manager = ConfigManager()
```

4. Use the configuration manager in your processing code:

```python
# document_processor.py
from .config_manager import config_manager

class DocumentProcessor:
    def process_document(self, document):
        model = config_manager.model
        output_file = config_manager.output_file
        # Process using selected model and output configuration
        ...
```

5. In your main API endpoint:

```python
# main.py
from fastapi import FastAPI, Depends
from .schemas import UserConfig, ProcessingConfig
from .config_manager import config_manager
from .document_processor import DocumentProcessor

app = FastAPI()

@app.post("/process")
async def process_document(
    document: UploadFile,
    config: UserConfig,
):
    # Convert user config to processing config
    processing_config = ProcessingConfig.from_user_config(config, settings)

    # Set the configuration for this processing run
    config_manager.set_config(processing_config)

    # Process the document using the configuration
    processor = DocumentProcessor()
    result = processor.process_document(document)

    return result
```

This approach offers several benefits:

1. **Validation**: Pydantic models ensure that configurations are valid
2. **Defaults**: Default values are handled gracefully
3. **Flexibility**: Users can provide partial configurations
4. **Type Safety**: Full type hints and validation throughout the codebase
5. **Separation of Concerns**: Clear separation between user inputs and internal configuration

The frontend can interact with this system by:

1. Fetching available models:
```javascript
const models = await fetch('/config/models').then(r => r.json());
```

2. Setting configuration when processing:
```javascript
await fetch('/process', {
  method: 'POST',
  body: formData, // contains document and config
  headers: {
    'Content-Type': 'multipart/form-data',
  },
});
```

This structure allows for easy extension of user-configurable options while maintaining type safety and validation throughout the application.
